#pragma kernel CSMain

/*********************************************
*					Structs
**********************************************/
struct MetaBrick
{
	float3 position;
	int size;
	int bufferIndex;
	int maxZLevel;
	int currentZLevel;
	int id;
	float3 boxMin;
	float3 boxMax;
	uint lastBitMask;
};

struct MetaVolume
{
	float3 position;
	float3 boxMin;
	float3 boxMax;
	float3 scale;
	int numBricks;
	int isHz;
	int numBits;
};

struct Ray
{
	float3 origin;
	float3 direction;
};

struct BrickIntersection
{
	int id;
	float tNear;
	float tFar;
};

/*********************************************
*			   Variables from C#
**********************************************/
RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
RWStructuredBuffer<MetaBrick> _MetaBrickBuffer;
RWStructuredBuffer<MetaVolume> _MetaVolumeBuffer;
RWStructuredBuffer<uint> _DataBuffer;

/*********************************************
*		     Newly Defined Variables
**********************************************/
const static int MAX_BRICKS = 5;										// TODO: Figure out why making this too big drastically decreases performance

/*********************************************
*			   Ray Init Functions
**********************************************/
Ray CreateRay(float3 origin, float3 direction)
{
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	return ray;
}

Ray CreateCameraRay(float2 uv)
{
	// Transform the camera origin to world space
	float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

	// Invert the perspective projection of the view-space position
	float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
	// Transform the direction from camera to world space and normalize
	direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
	direction = normalize(direction);

	return CreateRay(origin, direction);
}

/*********************************************
*			 Intersection function(s)
**********************************************/
// Calculates intersection between a ray and a box
bool IntersectBox(float3 ray_o, float3 ray_d, float3 boxMin, float3 boxMax, out float tNear, out float tFar)
{
	// Compute intersection of ray with all six bbox planes
	float3 invR = 1.0 / ray_d;
	float3 tBot = invR * (boxMin.xyz - ray_o);
	float3 tTop = invR * (boxMax.xyz - ray_o);

	// Re-order intersections to find smallest and largest on each axis
	float3 tMin = min(tTop, tBot);
	float3 tMax = max(tTop, tBot);

	// Find the largest tMin and the smallest tMax
	float2 t0 = max(tMin.xx, tMin.yz);
	float largest_tMin = max(t0.x, t0.y);
	t0 = min(tMax.xx, tMax.yz);
	float smallest_tMax = min(t0.x, t0.y);

	// Check for hit
	bool hit = (largest_tMin <= smallest_tMax);
	tNear = largest_tMin;
	tFar = smallest_tMax;
	return hit;
}

/*********************************************
*			  HZ Curving Functions
**********************************************/
uint Compact1By2(uint x)
{
	x &= 0x09249249;                  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
	x = (x ^ (x >> 2)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
	x = (x ^ (x >> 4)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
	x = (x ^ (x >> 8)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
	x = (x ^ (x >> 16)) & 0x000003ff; // x = ---- ---- ---- ---- ---- --98 7654 3210
	return x;
}

uint DecodeMorton3X(uint code)
{
	return Compact1By2(code >> 2);
}

uint DecodeMorton3Y(uint code)
{
	return Compact1By2(code >> 1);
}

uint DecodeMorton3Z(uint code)
{
	return Compact1By2(code >> 0);
}

uint3 decode(uint c, uint lastBitMask)
{
	uint3 cartEquiv = uint3(0, 0, 0);
	c = c << 1 | 1;
	uint i = c | c >> 1;
	i |= i >> 2;
	i |= i >> 4;
	i |= i >> 8;
	i |= i >> 16;

	i -= i >> 1;

	c *= lastBitMask / i;
	c &= (~lastBitMask);
	cartEquiv.x = DecodeMorton3X(c);
	cartEquiv.y = DecodeMorton3Y(c);
	cartEquiv.z = DecodeMorton3Z(c);

	return cartEquiv;
}

// Expands an 8-bit integer into 24 bits by inserting 2 zeros after each bit
// Taken from: https://webcache.googleusercontent.com/search?q=cache:699-OSphYRkJ:https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/+&cd=1&hl=en&ct=clnk&gl=us
uint Part1By2(uint x)
{
	x &= 0x000003ff;                  // x = ---- ---- ---- ---- ---- --98 7654 3210
	x = (x ^ (x << 16)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
	x = (x ^ (x << 8)) & 0x0300f00f;  // x = ---- --98 ---- ---- 7654 ---- ---- 3210
	x = (x ^ (x << 4)) & 0x030c30c3;  // x = ---- --98 ---- 76-- --54 ---- 32-- --10
	x = (x ^ (x << 2)) & 0x09249249;  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
	return x;
}

// Calculates a 24-bit Morton code for the given 3D point located within the unit cube [0, 1]
// Taken from: https://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/
uint morton3D(float3 pos, int brickSize)
{
	// Quantize to the correct resolution
	pos.x = min(max(pos.x * (float)brickSize, 0.0f), (float)brickSize - 1);
	pos.y = min(max(pos.y * (float)brickSize, 0.0f), (float)brickSize - 1);
	pos.z = min(max(pos.z * (float)brickSize, 0.0f), (float)brickSize - 1);

	// Interlace the bits
	uint xx = Part1By2((uint) pos.x);
	uint yy = Part1By2((uint) pos.y);
	uint zz = Part1By2((uint) pos.z);

	return zz << 2 | yy << 1 | xx;
}

// Return the index into the hz-ordered array of data given a quantized point within the volume
uint getHZIndex(uint zIndex, uint lastBitMask)
{
	uint hzIndex = (zIndex | lastBitMask);		// set leftmost one
	hzIndex /= hzIndex & -hzIndex;				// remove trailing zeros
	return (hzIndex >> 1);						// remove rightmost one
}

// Returns the masked z index, allowing for the the data to be quantized to a level of detail specified by the _CurrentZLevel.
uint computeMaskedZIndex(uint zIndex, int currentZLevel, int maxZLevel)
{
	int zBits = maxZLevel * 3;
	uint zMask = -1 >> (zBits - 3 * currentZLevel) << (zBits - 3 * currentZLevel);
	return zIndex & zMask;
}

/*********************************************
*		  Intensity Sampling Functions
**********************************************/
// Samples from the data buffer as if it were filled with raw ordered data.
// Formula: x + (y * width) + (z * width * height)
float sampleIntensityRaw(float3 pos, int width, int height, int depth, int bufferOffset)
{
	// Convert from texture coordinates to 3d cartesian
	//uint x = round(pos.x);// / (float)width);
	//uint y = round(pos.y);// / (float)height);
	//uint z = round(pos.z);// / (float)depth);
	//uint index = (x + width * (y + (z * height)));
	//int index = round(pos.x + width * (pos.y + (pos.z * height)));

	// TESTING
	uint x = floor(lerp(0, width, pos.x));
	uint y = floor(lerp(0, height, pos.y));
	uint z = floor(lerp(0, depth, pos.z));
	uint index = (x + width * (y + (z * height)));
	// END TESTING

	return _DataBuffer[bufferOffset + index];
}

// Samples from the data buffer as if it were filled with HZ ordered data.
float sampleIntensityHz(float3 pos, MetaBrick brick)
{
	uint zIndex = morton3D(pos, brick.size);												// Get the Z order index		
	uint maskedZIndex = computeMaskedZIndex(zIndex, brick.currentZLevel, brick.maxZLevel);	// Get the masked Z index
	uint hzIndex = getHZIndex(maskedZIndex, brick.lastBitMask);								// Find the hz order index
	return _DataBuffer[brick.bufferIndex + hzIndex];
}

float sampleIntensity(float3 pos, MetaBrick brick, bool isHz)
{
	if (isHz)
		return sampleIntensityHz(pos, brick);
	else
		return sampleIntensityRaw(pos, brick.size, brick.size, brick.size, brick.bufferIndex);
}

/*********************************************
*	  Transfer Function Sampling Function(s)
**********************************************/
float4 sampleTransferFunction(float isovalue)
{
	//float alpha = 0.2;
	//if (isovalue < 40)
	//	return float4(1, 0, 0, alpha);
	//if (isovalue < 80)
	//	return float4(1, 1, 0, alpha);
	//if (isovalue < 120)
	//	return float4(0, 1, 0, alpha);
	//if (isovalue < 160)
	//	return float4(0, 1, 1, alpha);
	//if (isovalue < 200)
	//	return float4(0, 0, 1, alpha);
	//if (isovalue < 240)
	//	return float4(1, 0, 1, alpha);
	//return float4(1, 1, 1, alpha);

	float4 startColor = float4(1,0,0,0);
	float4 endColor = float4(0,0,1,1);
	return lerp(startColor, endColor, isovalue / 255.0);
}


/*********************************************
*		      Sorting Function(s)
**********************************************/
void insertionSort(inout BrickIntersection a[MAX_BRICKS], int length)							// TODO: Maybe just have 'a' be of type out instead of inout
{
	int i, j;
	BrickIntersection value;
	for (i = 1; i < length; i++)
	{
		value = a[i];
		for (j = i - 1; j >= 0 && a[j].tNear > value.tNear; j--)
			a[j + 1] = a[j];
		a[j + 1] = value;
	}
}

/*********************************************
*			  Main Function Kernel
**********************************************/
[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// Get the dimensions of the RenderTexture
	uint width, height;
	Result.GetDimensions(width, height);

	// Transform pixel to [-1,1] range
	float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

	Result[id.xy] = float4(1,0,0,1);

	// Get a ray for the UVs
	Ray ray = CreateCameraRay(uv);

	// Calculate eye ray intersection with cube bounding box
	float3 boxMin = _MetaVolumeBuffer[0].boxMin;
	float3 boxMax = _MetaVolumeBuffer[0].boxMax;

	float volume_tNear, volume_tFar;
	bool hit = IntersectBox(ray.origin, ray.direction, boxMin, boxMax, volume_tNear, volume_tFar);

	if (!hit)
	{
		Result[id.xy] = float4(0, 0, 0, 1);
		return;
	}
	//else
	//{
	//	// TEST
	//	Result[id.xy] = float4(0, 1, 0, 1);
	//	return;
	//}

	// Check intersections with all each of the bricks
	BrickIntersection intersections[MAX_BRICKS];
	int numIntersections = 0;
	for (int i = 0; i < _MetaVolumeBuffer[0].numBricks; i++)
	{
		BrickIntersection newIntersection;
		if (IntersectBox(ray.origin, ray.direction, _MetaBrickBuffer[i].boxMin, _MetaBrickBuffer[i].boxMax, newIntersection.tNear, newIntersection.tFar))
		{
			newIntersection.id = _MetaBrickBuffer[i].id;
			intersections[numIntersections] = newIntersection;
			numIntersections++;
		}
	}
	
	// Ensure that some brick was hit by the ray
	if (numIntersections == 0)
	{
		Result[id.xy] = float4(0, 0, 1, 1);
		return;
	}
	//else
	//{
	//	// TEST
	//	Result[id.xy] = float4(numIntersections / 4.0f, numIntersections / 4.0f, numIntersections / 4.0f, 1);
	//	return;
	//}

	// BEGIN TESTING: Test the distance of the intersection
	//float3 pNear = ray.origin + (ray.direction * global_tNear);
	//float3 pFar = ray.origin + (ray.direction * global_tFar);
	//Result[id.xy] = float4(pNear, 1);
	//Result[id.xy] = float4(pFar, 1);
	//return;
	// END TESTING

	// Sort the bricks by smallest nearT
	insertionSort(intersections, numIntersections);

	// TODO: Set up the step size
	int _Steps = 128;

	// ORIGINAL
	//// Set up ray stepping size and step vector
	//float distancePerStep = sqrt(3) / (float) _Steps;
	//float3 ray_step = ray.direction * distancePerStep;

	//float totalDistance = global_tFar - global_tNear;
	//float globalDistanceTraveled = 0.0f;
	//float localDistanceTraveled = 0.0f;
	//int currentIntersectionIndex = 0;
	//float3 localRayStart = (ray.origin + ray.direction * intersections[currentIntersectionIndex].tNear) - _MetaBrickBuffer[intersections[currentIntersectionIndex].id].boxMin;
	//float3 localRayEnd = (ray.origin + ray.direction * intersections[currentIntersectionIndex].tFar) - _MetaBrickBuffer[intersections[currentIntersectionIndex].id].boxMin;
	//float3 local_ray_pos = localRayStart;

	//// Perform the ray marching
	//float4 fColor = 0;
	//for (int k = 0; k < _Steps; k++)
	//{
	//	// Determine the value at this point on the current ray
	//	float intensity = sampleIntensity(local_ray_pos, _MetaBrickBuffer[currentIntersectionIndex], _MetaVolumeBuffer[0].isHz);

	//	// Sample from the texture generated by the transfer function
	//	float4 sampleColor = sampleTransferFunction(intensity);				// TODO: Add a transfer function sampler

	//	// Front to back blending function
	//	fColor.rgb = fColor.rgb + (1 - fColor.a) * sampleColor.a * sampleColor.rgb;
	//	fColor.a = fColor.a + (1 - fColor.a) * sampleColor.a;

	//	// March along the ray
	//	local_ray_pos += ray_step;

	//	// Update the distance traveled
	//	globalDistanceTraveled += distancePerStep;
	//	localDistanceTraveled += distancePerStep;

	//	// Check if we have marched out of the volume
	//	if (globalDistanceTraveled > totalDistance)
	//		break;

	//	// Check if we have marched out of the current brick and update the current brick/ray information if so
	//	if (localDistanceTraveled > intersections[currentIntersectionIndex].tFar && currentIntersectionIndex != numIntersections)
	//	{
	//		currentIntersectionIndex++;
	//		float3 localRayStart = (ray.origin + ray.direction * intersections[currentIntersectionIndex].tNear) - _MetaBrickBuffer[intersections[currentIntersectionIndex].id].boxMin;
	//		float3 localRayEnd = (ray.origin + ray.direction * intersections[currentIntersectionIndex].tFar) - _MetaBrickBuffer[intersections[currentIntersectionIndex].id].boxMin;
	//		local_ray_pos = localRayStart;
	//	}
	//	else
	//		break;

	//	// Check if accumulated alpha is greater than 1.0
	//	if (fColor.a > 1.0) break;
	//}

	////Result[id.xy] = float4(0, fColor.a, 0, 1);
	//Result[id.xy] = fColor;
	
	// END ORIGINAL

	// BEGIN TESTING
	int currentBrickIndex = 0;
	MetaBrick currentBrick = _MetaBrickBuffer[intersections[currentBrickIndex].id];
	MetaVolume currentVolume = _MetaVolumeBuffer[0];

	float3 pNear = ray.origin + (ray.direction * volume_tNear);
	float3 pFar = ray.origin + (ray.direction * volume_tFar);

	float3 rayStart = pNear;
	float3 rayStop = pNear;

	float3 vol_ray_pos = rayStart;
	float3 brick_ray_pos = vol_ray_pos - currentBrick.boxMin;

	float3 ray_step = ray.direction * sqrt(3) / _Steps;

	float4 fColor = 0;
	for (int k = 0; k < _Steps; k++)
	{
		float isovalue = sampleIntensity(brick_ray_pos, currentBrick, currentVolume.isHz);

		float4 sampleColor = sampleTransferFunction(isovalue);
		
		// Front to back blending function
		fColor.rgb = fColor.rgb + (1 - fColor.a) * sampleColor.a * sampleColor.rgb;
		fColor.a = fColor.a + (1 - fColor.a) * sampleColor.a;

		vol_ray_pos += ray_step;
		brick_ray_pos += ray_step;

		// Check if we have marched out of the volume
		if (vol_ray_pos.x < currentVolume.boxMin.x || vol_ray_pos.y < currentVolume.boxMin.y || vol_ray_pos.z < currentVolume.boxMin.z)
			break;
		if (vol_ray_pos.x > currentVolume.boxMax.x || vol_ray_pos.y > currentVolume.boxMax.y || vol_ray_pos.z > currentVolume.boxMax.z)
			break;

		// Check if we have marched out of the current brick
		if (brick_ray_pos.x < currentBrick.boxMin.x || brick_ray_pos.y < currentBrick.boxMin.y || brick_ray_pos.z < currentBrick.boxMin.z
			|| brick_ray_pos.x > currentBrick.boxMax.x || brick_ray_pos.y > currentBrick.boxMax.y || brick_ray_pos.z > currentBrick.boxMax.z)
		{
			if (currentBrickIndex < numIntersections)
			{
				currentBrickIndex++;
				currentBrick = _MetaBrickBuffer[intersections[currentBrickIndex].id];
				brick_ray_pos = vol_ray_pos - currentBrick.boxMin;
			}
			else
				break;
		}

		// Check if accumulated alpha is greater than 1.0
		if (fColor.a > 1.0) 
			break;
	}

	Result[id.xy] = fColor;
	// END TESTING
}
