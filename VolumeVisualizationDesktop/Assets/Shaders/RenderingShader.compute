#pragma kernel CSMain

/*********************************************
*					Structs
**********************************************/
struct MetaBrick
{
	float3 position;
	int size;
	int bufferOffset;
	int bufferIndex;
	int maxZLevel;
	int currentZLevel;
	int id;
	float3 boxMin;
	float3 boxMax;
	uint lastBitMask;
};

struct MetaVolume
{
	float3 position;
	float3 boxMin;
	float3 boxMax;
	float3 scale;
	int numBricks;
	int isHz;
	int numBits;
	int maxGlobalSize;
};

struct Ray
{
	float3 origin;
	float3 direction;
};

struct BrickIntersection
{
	int id;
	float tNear;
	float tFar;
};

/*********************************************
*			   Variables from C#
**********************************************/
RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
RWStructuredBuffer<MetaBrick> _MetaBrickBuffer;
RWStructuredBuffer<MetaVolume> _MetaVolumeBuffer;
RWStructuredBuffer<uint> _DataBufferZero;
RWStructuredBuffer<uint> _DataBufferOne;
RWStructuredBuffer<uint> _DataBufferTwo;
int _Steps = 128;
Texture2D<float4> _TransferFunctionTexture;
SamplerState sampler_TransferFunctionTexture;

/*********************************************
*		     Newly Defined Variables
**********************************************/
const static int MAX_BRICKS = 20;										// TODO: Figure out why making this too big drastically decreases performance

// big endian
const static uint MASKS_8BIT[] = {0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF};
const static int BYTE_SHIFTS[] = { 24, 16, 8, 0 };

// little endian
//const static uint MASKS_8BIT[] = { 0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000 };
//const static int BYTE_SHIFTS[] = { 0, 8, 16, 24 };

/*********************************************
*			   Ray Init Functions
**********************************************/
Ray CreateRay(float3 origin, float3 direction)
{
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	return ray;
}

Ray CreateCameraRay(float2 uv)
{
	// Transform the camera origin to world space
	float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

	// Invert the perspective projection of the view-space position
	float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
	// Transform the direction from camera to world space and normalize
	direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
	direction = normalize(direction);

	return CreateRay(origin, direction);
}

/*********************************************
*			 Intersection function(s)
**********************************************/
// Calculates intersection between a ray and a box
bool IntersectBox(float3 ray_o, float3 ray_d, float3 boxMin, float3 boxMax, out float tNear, out float tFar)
{
	// Compute intersection of ray with all six bbox planes
	float3 invR = 1.0 / ray_d;
	float3 tBot = invR * (boxMin.xyz - ray_o);
	float3 tTop = invR * (boxMax.xyz - ray_o);

	// Re-order intersections to find smallest and largest on each axis
	float3 tMin = min(tTop, tBot);
	float3 tMax = max(tTop, tBot);

	// Find the largest tMin and the smallest tMax
	float2 t0 = max(tMin.xx, tMin.yz);
	float largest_tMin = max(t0.x, t0.y);
	t0 = min(tMax.xx, tMax.yz);
	float smallest_tMax = min(t0.x, t0.y);

	// Check for hit
	bool hit = (largest_tMin <= smallest_tMax);
	tNear = largest_tMin;
	tFar = smallest_tMax;
	return hit;
}

/*********************************************
*			  HZ Curving Functions
**********************************************/
// Expands an 8-bit integer into 24 bits by inserting 2 zeros after each bit
// Taken from: https://webcache.googleusercontent.com/search?q=cache:699-OSphYRkJ:https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/+&cd=1&hl=en&ct=clnk&gl=us
uint Part1By2(uint x)
{
	x &= 0x000003ff;                  // x = ---- ---- ---- ---- ---- --98 7654 3210
	x = (x ^ (x << 16)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
	x = (x ^ (x << 8)) & 0x0300f00f;  // x = ---- --98 ---- ---- 7654 ---- ---- 3210
	x = (x ^ (x << 4)) & 0x030c30c3;  // x = ---- --98 ---- 76-- --54 ---- 32-- --10
	x = (x ^ (x << 2)) & 0x09249249;  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
	return x;
}

// Calculates a 24-bit Morton code for the given 3D point located within the unit cube [0, 1]
// Taken from: https://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/
uint morton3D(float3 pos, int brickSize)
{
	// Quantize to the correct resolution
	pos.x = min(max(pos.x * (float)brickSize, 0.0f), (float)brickSize - 1);
	pos.y = min(max(pos.y * (float)brickSize, 0.0f), (float)brickSize - 1);
	pos.z = min(max(pos.z * (float)brickSize, 0.0f), (float)brickSize - 1);

	// Interlace the bits
	uint xx = Part1By2((uint) pos.x);
	uint yy = Part1By2((uint) pos.y);
	uint zz = Part1By2((uint) pos.z);

	return zz << 2 | yy << 1 | xx;
}

// Returns the masked z index, allowing for the the data to be quantized to a level of detail specified by the _CurrentZLevel.
uint computeMaskedZIndex(uint zIndex, int currentZLevel, int maxZLevel)
{
	int zBits = maxZLevel * 3;
	uint zMask = -1 >> (zBits - 3 * currentZLevel) << (zBits - 3 * currentZLevel);
	return zIndex & zMask;
}

// Return the index into the hz-ordered array of data given a quantized point within the volume
uint getHZIndex(uint zIndex, uint lastBitMask)
{
	uint hzIndex = (zIndex | lastBitMask);		// set leftmost one
	hzIndex /= hzIndex & -hzIndex;				// remove trailing zeros
	return (hzIndex >> 1);						// remove rightmost one
}

/*********************************************
*		  Intensity Sampling Functions
**********************************************/
// Samples from the data buffer with the assumption that each data point is 8 bit stored in a 32 bit uint
float sampleDataBuffer8Bit(uint bufferOffset, uint byteIndex) 
{
	uint uintIndex = bufferOffset + ceil(byteIndex / 4.0);				// Find the index of the desired uint								// PROBLEM: Does the ceil() function need to be cast to uint before adding it to the bufferOffset?
	uint uintIndexOffset = 3- (byteIndex % 4);						// Find the offset into the desired uint
	return (_DataBufferZero[uintIndex] & MASKS_8BIT[uintIndexOffset]) >> BYTE_SHIFTS[uintIndexOffset];

	//return _DataBufferZero[uintIndex] & 0x000000FF;
}

float sampleBuffers(uint bufferIndex, uint bufferOffset, uint byteIndex)
{
	//uint uintIndex = bufferOffset + ceil(byteIndex / 4.0);				// Find the index of the desired uint
	//uint uintIndex = bufferOffset + (byteIndex / 4);
	uint uintIndex = bufferOffset + byteIndex;
	uint uintIndexOffset = 3 - (byteIndex % 4);						// Find the offset into the desired uint

	if (bufferIndex == 0)
	{
		return _DataBufferZero[uintIndex];
		//return (_DataBufferZero[uintIndex] & MASKS_8BIT[uintIndexOffset]) >> BYTE_SHIFTS[uintIndexOffset];
	}
	else if (bufferIndex == 1)
	{
		return _DataBufferOne[uintIndex];
		//return (_DataBufferOne[uintIndex] & MASKS_8BIT[uintIndexOffset]) >> BYTE_SHIFTS[uintIndexOffset];
	}
	else if (bufferIndex == 2)
	{
		return _DataBufferTwo[uintIndex];
		//return (_DataBufferTwo[uintIndex] & MASKS_8BIT[uintIndexOffset]) >> BYTE_SHIFTS[uintIndexOffset];
	}
	else
	{
		return 0;
	}
}

float samplePackedBuffers(uint bufferIndex, uint bufferOffset, uint byteIndex)
{
	uint uintIndex = bufferOffset + (byteIndex / 4);
	uint uintIndexOffset = byteIndex % 4;
	if (bufferIndex == 0)
	{
		return (_DataBufferZero[uintIndex] & MASKS_8BIT[uintIndexOffset]) >> BYTE_SHIFTS[uintIndexOffset];
	}
	else if (bufferIndex == 1)
	{
		return (_DataBufferOne[uintIndex] & MASKS_8BIT[uintIndexOffset]) >> BYTE_SHIFTS[uintIndexOffset];
	}
	else if (bufferIndex == 2)
	{
		return (_DataBufferTwo[uintIndex] & MASKS_8BIT[uintIndexOffset]) >> BYTE_SHIFTS[uintIndexOffset];
	}
	else
	{
		return 0;
	}
}

// Samples from the data buffer as if it were filled with raw ordered data.
// Formula: x + (y * width) + (z * width * height)
// pos is assumed to in local brick space
float sampleIntensityRaw(float3 pos, int width, int height, int depth, int bufferIndex, int bufferOffset)
{
	// Convert from texture coordinates to 3d cartesian
	//uint x = round(pos.x);// / (float)width);
	//uint y = round(pos.y);// / (float)height);
	//uint z = round(pos.z);// / (float)depth);
	//uint index = (x + width * (y + (z * height)));
	//int index = round(pos.x + width * (pos.y + (pos.z * height)));

	uint x = floor(lerp(0, width - 1, pos.x));
	uint y = floor(lerp(0, height - 1, pos.y));	// flip the y coordinate due to how the data is stored (0 is top, 1 is bottom)
	uint z = floor(lerp(0, depth - 1, pos.z));
	uint index = (x + width * (y + (z * height)));

	// ORIGINAl
	//return _DataBufferZero[bufferOffset + index];

	// TESTING BYTES PACKED INTO UINTS
	//return sampleDataBuffer8Bit(bufferOffset, index);

	// TESTING MULTIPLE UINT BUFFERS
	//return sampleBuffers(bufferIndex, bufferOffset, index);

	// TESTING MULTIPLE PACKED UINT BUFFERS
	return samplePackedBuffers(bufferIndex, bufferOffset, index);
}

// Samples from the data buffer as if it were filled with HZ ordered data.
float sampleIntensityHz(float3 pos, MetaBrick brick)
{
	uint zIndex = morton3D(pos, brick.size);												// Get the Z order index		
	uint maskedZIndex = computeMaskedZIndex(zIndex, brick.currentZLevel, brick.maxZLevel);	// Get the masked Z index
	uint hzIndex = getHZIndex(maskedZIndex, brick.lastBitMask);								// Find the hz order index
	//return _DataBufferZero[brick.bufferOffset + hzIndex];
	return sampleDataBuffer8Bit(brick.bufferOffset, hzIndex);
}

float sampleIntensity(float3 pos, MetaBrick brick, bool isHz)
{
	// Transform pos from world space to local brick space
	pos = (pos - brick.boxMin) * (_MetaVolumeBuffer[0].maxGlobalSize / brick.size);

	if (isHz)
		return sampleIntensityHz(pos, brick);
	else
		return sampleIntensityRaw(pos, brick.size, brick.size, brick.size, brick.bufferIndex, brick.bufferOffset);
}

/*********************************************
*	  Transfer Function Sampling Function(s)
**********************************************/
float4 sampleTransferFunction(float isovalue)
{
	//float alpha = 0.2;
	//if (isovalue < 40)
	//	return float4(1, 0, 0, alpha);
	//if (isovalue < 80)
	//	return float4(1, 1, 0, alpha);
	//if (isovalue < 120)
	//	return float4(0, 1, 0, alpha);
	//if (isovalue < 160)
	//	return float4(0, 1, 1, alpha);
	//if (isovalue < 200)
	//	return float4(0, 0, 1, alpha);
	//if (isovalue < 240)
	//	return float4(1, 0, 1, alpha);
	//return float4(1, 1, 1, alpha);

	// Hot to cold transfer function
	//float4 startColor = float4(1.0, 1.0, 0.0, 0.0);
	//float4 endColor = float4(0.8, 0.0, 0.8, 0.2);
	//return lerp(startColor, endColor, isovalue / 255.0);

	//// Determine the proper color
	//float3 startColor = float3(1.0, 1.0, 0.0);
	//float3 endColor = float3(0.8, 0.0, 0.8);
	//float3 lerpColor = lerp(startColor, endColor, isovalue / 255.0);

	//// Determine the proper alpha
	//float startAlpha = 0;
	//float endAlpha = 0;
	//if (isovalue < 50)
	//{
	//	startAlpha = 0.0;
	//	endAlpha = 1.0;
	//}
	//else
	//{
	//	startAlpha = 1.0;
	//	endAlpha = 0.0; 
	//}
	//float lerpAlpha = lerp(startAlpha, endAlpha, isovalue / 255.0);
	//
	//return float4(lerpColor, lerpAlpha); 

	// Only need to sample along the x axis of the texture (8-BIT ONLY)
	return _TransferFunctionTexture.SampleLevel(sampler_TransferFunctionTexture, float2(isovalue/255, 0.0), 0.0);
}


/*********************************************
*		      Sorting Function(s)
**********************************************/
void insertionSort(inout BrickIntersection a[MAX_BRICKS], int length)							// TODO: Maybe just have 'a' be of type out instead of inout
{
	int i, j;
	BrickIntersection value;
	for (i = 1; i < length; i++)
	{
		value = a[i];
		for (j = i - 1; j >= 0 && a[j].tNear > value.tNear; j--)
			a[j + 1] = a[j];
		a[j + 1] = value;
	}
}

/*********************************************
*			  Main Function Kernel
**********************************************/
[numthreads(32, 32, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Get the dimensions of the RenderTexture
	uint width, height;
	Result.GetDimensions(width, height);

	// Transform pixel to [-1,1] range
	float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

	Result[id.xy] = float4(0, 0, 0, 1);

	// Get a ray for the UVs
	Ray ray = CreateCameraRay(uv);

	// Calculate eye ray intersection with cube bounding box
	float3 boxMin = _MetaVolumeBuffer[0].boxMin;
	float3 boxMax = _MetaVolumeBuffer[0].boxMax;

	float volume_tNear, volume_tFar;
	bool hit = IntersectBox(ray.origin, ray.direction, boxMin, boxMax, volume_tNear, volume_tFar);

	// If there was no intersection with the volume, color the pixel black and do nothing
	if (!hit)
	{
		Result[id.xy] = float4(0, 0, 0, 0);
		return;
	}
	//else
	//{
	//	// TEST
	//	Result[id.xy] = float4(0, 1, 0, 1);
	//	return;
	//}

	// Check intersections with all each of the bricks
	BrickIntersection intersections[MAX_BRICKS];
	int numIntersections = 0;
	for (int i = 0; i < _MetaVolumeBuffer[0].numBricks; i++)
	{
		BrickIntersection newIntersection;
		if (IntersectBox(ray.origin, ray.direction, _MetaBrickBuffer[i].boxMin, _MetaBrickBuffer[i].boxMax, newIntersection.tNear, newIntersection.tFar))
		{
			newIntersection.id = _MetaBrickBuffer[i].id;
			intersections[numIntersections] = newIntersection;
			numIntersections++;
		}
	}

	// Ensure that some brick was hit by the ray
	if (numIntersections == 0)
	{
		Result[id.xy] = float4(1, 0, 0, 1);
		return;
	}
	//else
	//{
	//	// TEST
	//	Result[id.xy] = float4(numIntersections / 4.0f, numIntersections / 4.0f, numIntersections / 4.0f, 1);
	//	return;
	//}

	// BEGIN TESTING: Test the distance of the intersection
	//float3 pNear = ray.origin + (ray.direction * global_tNear);
	//float3 pFar = ray.origin + (ray.direction * global_tFar);
	//Result[id.xy] = float4(pNear, 1);
	//Result[id.xy] = float4(pFar, 1);
	//return;
	// END TESTING

	// Sort the bricks by smallest nearT
	insertionSort(intersections, numIntersections);

	// BEGIN TESTING
	int currentBrickIndex = 0;
	MetaBrick currentBrick = _MetaBrickBuffer[intersections[currentBrickIndex].id];
	MetaVolume currentVolume = _MetaVolumeBuffer[0];

	//float3 pNear = ray.origin + (ray.direction * volume_tNear);
	//float3 pFar = ray.origin + (ray.direction * volume_tFar);
	float3 pNear = ray.origin + (ray.direction * intersections[currentBrickIndex].tNear);
	float3 pFar = ray.origin + (ray.direction * intersections[currentBrickIndex].tFar);

	float3 rayStart = pNear; 
	//float3 rayStop = pFar;

	float3 vol_ray_pos = rayStart;
	float3 brick_ray_pos = vol_ray_pos - currentBrick.boxMin;

	float3 ray_step = ray.direction * sqrt(3) / _Steps;

	float4 fColor = 0;
	for (int k = 0; k < _Steps; k++)
	{
		float isovalue = sampleIntensity(vol_ray_pos, currentBrick, currentVolume.isHz);

		float4 sampleColor = sampleTransferFunction(isovalue);
		//float4 sampleColor = float4(1.0, 0.0, 0.0, 0.005);

		// Front to back blending function
		fColor.rgb = fColor.rgb + (1 - fColor.a) * sampleColor.a * sampleColor.rgb;
		fColor.a = fColor.a + (1 - fColor.a) * sampleColor.a;

		vol_ray_pos += ray_step;
		brick_ray_pos += ray_step;
		//brick_ray_pos = vol_ray_pos - currentBrick.boxMin;

		// Check if we have marched out of the volume
		if (vol_ray_pos.x < currentVolume.boxMin.x || vol_ray_pos.y < currentVolume.boxMin.y || vol_ray_pos.z < currentVolume.boxMin.z
			|| vol_ray_pos.x > currentVolume.boxMax.x || vol_ray_pos.y > currentVolume.boxMax.y || vol_ray_pos.z > currentVolume.boxMax.z)
			break;

		// Check if we have marched out of the current brick
		if (vol_ray_pos.x < currentBrick.boxMin.x || vol_ray_pos.y < currentBrick.boxMin.y || vol_ray_pos.z < currentBrick.boxMin.z
			|| vol_ray_pos.x > currentBrick.boxMax.x || vol_ray_pos.y > currentBrick.boxMax.y || vol_ray_pos.z > currentBrick.boxMax.z)
		{
			if (currentBrickIndex < numIntersections)
			{
				currentBrickIndex++;
				currentBrick = _MetaBrickBuffer[intersections[currentBrickIndex].id];
			}
			else
				break;
		}

		// If alpha is completely saturated for this pixel, stop ray-marching
		if (fColor.a > 1.0) 
			break;
	}

	Result[id.xy] = fColor;
	// END TESTING
}
